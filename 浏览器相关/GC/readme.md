>@Author: 刘子民
> @Date: 2020-05-29 12:06:28
> @LastEditTime: 2020-05-29 12:06:29

# 垃圾回收(Garbage Collection )

由于JavaScript 原始数据类型存储在栈中，引用类型存储在堆中。使用变量的时候我们分配内存，那么我们什么时候对这些内存进行回收呢？

**对于不同的语言有着不同的回收机制：**通常GC 分为手动回收和**自动回收**两种。

如C/C++ 就是手动回收，当我们需要申请堆中的内存时，我们需要手动的申请与释放，如果不释放内存就会造成内存泄漏。

```c
// C 代码
//在堆中分配内存
char* p =  (char*)malloc(2048);  //在堆空间中分配2048字节的空间，并将分配后的引用地址保存到p中
 
 //使用p指向的内存
 {
   //....
 }
 
//使用结束后，销毁这段内存
free(p)；
p = NULL；
```

而像 JavaScript、Java、python 等语言的垃圾回收都是由**垃圾回收器**来完成的。

至于垃圾回收的常用机制，之后可能会总结一篇。

## 栈内存回收

![image-20200529144353060](C:\Users\刘子民\AppData\Roaming\Typora\typora-user-images\image-20200529144353060.png)

可以看到当运行到第一个断点时，这个时候当前调用栈指向showName。

![image-20200529144603415](C:\Users\刘子民\AppData\Roaming\Typora\typora-user-images\image-20200529144603415.png)

运行到第二个断点时，由于showName 函数已经执行完成，被GC 回收。

![image-20200529144704102](C:\Users\刘子民\AppData\Roaming\Typora\typora-user-images\image-20200529144704102.png)

到第三个断点的时候，foo() 函数被执行完，foo() 被GC。此时调用栈指向全局上下文。这个指向当前上下文的指针就叫做ESP。先科普一下什么是ESP与EBP。

1. ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶（下一个压入栈的活动记录的顶部），是栈指针。
2. EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部(当前活动记录的底部),是帧指针。

esp是栈顶指针寄存器，ebp是栈底指针寄存器。

由于showName 函数被执行完，ESP与EBP发生移动，分别指向foo调用栈的栈顶与栈底，虽然此时showName 的调用栈仍然在栈中，但是由于ESP 指向foo的调用栈，showName 那部分的内存是无法被访问的，当我们后续操作需要新建一个函数栈的时候，showName 的那部分数据就会被覆盖掉。

所以说，当一个函数执行结束之后，**JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文**。



## 堆内存回收

当我们foo 也执行结束后，此时ESP 指向全局执行上下文，他们栈中的数据被回收了，然而对于堆中的内存是如何回收的呢？

堆中的垃圾回收我们就需要用到JavaScript中的垃圾回收器了。所以，接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。我们需要了解这两个概念。

### 代际假说和分代收集

代际假说有以下两个特点：

- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 第二个是不死的对象，会活得更久。

在 V8 中会把堆分为**新生代**和**老生代**两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。

对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

- 副垃圾回收器，主要负责新生代的垃圾回收。
- 主垃圾回收器，主要负责老生代的垃圾回收。

### 垃圾回收器的工作流程

不论什么类型的垃圾回收器，它们都有一套共同的执行流程。

1. 标记空间中**活动对象**和**非活动对象**。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
2. 回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
3. 内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为**有的垃圾回收器不会产生内存碎片**，比如接下来我们要介绍的副垃圾回收器。

### 副垃圾回收器

新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：

![](https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png)

新创建的对象会被分配到新生区的对象区域，当对象区域快要满的时候，就执行一次垃圾回收操作。

在垃圾回收的过程中，首先要对对象区域中的垃圾做标记，比如引用计数等操作，进入清理阶段，副垃圾回收器会将存活的对象复制到空闲区域，可以说是连续的排在一起，这样就完成了整理操作，此时空闲区域就没有碎片存在，复制完成之后，将对象区域与空闲区域角色互换，这样就完成垃圾回收操作。由于我们的新生区采用的Scavenge 算法，每一次的GC 对象区域和空闲区域都会复制互换，所以**为了执行效率，一般新生区的空间会被设置得比较小。**

但是这样对象区域比较小，容易被使用完，所以JavaScript 引擎采用了**对象晋升策略**，即经过两次垃圾回收的对象会被移动到老生区中。



### 主垃圾回收

主垃圾回收器主要负责老生区中的垃圾回收。

主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。

由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。

首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：

![](https://static001.geekbang.org/resource/image/6c/69/6c8361d3e52c1c37a06699ed94652e69.png)

当栈中不存在堆中的地址时，该内存就可以被认为是垃圾数据。

接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：

![](https://static001.geekbang.org/resource/image/d0/85/d015db8ad0df7f0ccb1bdb8e31f96e85.png)

上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：

![](https://static001.geekbang.org/resource/image/65/8c/652bd2df726d0aa5e67fe8489f39a18c.png)

### 全停顿

由于JavaScript 是单线程，因此在执行垃圾回收算法时，会将正在执行的脚本暂停下来，待执行完垃圾回收算法后再回复执行。这就是全停顿(Stop-The-World)。

比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：

![](https://static001.geekbang.org/resource/image/98/0c/9898646a08b46bce4f12f918f3c1e60c.png)

全停顿在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。

![](https://static001.geekbang.org/resource/image/de/e7/de117fc96ae425ed90366e9060aa14e7.png)

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：增量标记使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。





本文参考自：

[13 | 垃圾回收：垃圾数据是如何自动回收的？](https://time.geekbang.org/column/article/131233)