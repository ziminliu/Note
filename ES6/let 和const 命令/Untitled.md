# 第2章 let 和 const 命令

## 2.1	let 命令

### 2.1.1	基本用法

let:只在声明的代码块内有效，适用于for循环结构

请看一下两段代码

```javascript

var a=[];
for(var i=0;i<10;i++){
  a[i]=function(){
    console.log(i)
  }
}
a[5]();   //10

var b=[];
for(let j=0;j<10;j++){
  b[j]=function(){
    console.log(j)
  }
}
b[5]();   //5
```

上述代码中，i 是var声明的，属于全局变量，所以全局只有一个i,而循环内的数组的函数内部每一个元素都指向的是同一个全局的i,因此，每一个i都是10.

而当使用let声明的变量j时，每一个j都只在当前的代码块有效，所以每次循环都是相当于一个新的变量，那么，既然每一次都时一个新的变量，那么它怎么知道知道上一轮循环的值，从而计算出本轮循环的值呢？其实JS引擎内部已经保存了上一轮循环的值，初始化本轮循环的值时，就是根据上一轮循环的值计算出来的.

既然我们使用let让每一次循环都打印出不同的值，那么我们是否可以用var声明变量打印出不同的值呢？答案当然是可以的，我们只需要使用立即执行函数和闭包就可以了。

另外，对于for循环来说，设置for循环变量的那部分是一个父作用域，而循环体的内部是一个单独的子作用域，

```js
for(let i=0;i<3;i++){
  let i='abc';
  console.log(i);
}
```

运行以上代码会打印出三次abc,这表明内部的变量i与循环变量的i不在同一个作用域，而是有着各自的作用域，当变量不在使用时，就释放该变量的空间。那么如果我们想打印循环变量的值该怎么办呢？用以下的代码？先打印父作用域的i，再打印出子作用域的i？

```js
for(let i=0;i<3;i++){
  console.log(i);
  let i='abc';
  console.log(i);
}
```

运行后我们会发现这段代码会报错，说**ReferenceError: i is not defined**。

当我们没有在子作用域中声明这个i时，编译器就会在这个从内部往外查找，使用父作用域的i,但是，当我们在子作用域声明了变量i 时，此时的i 与父元素的i就不是同一个i ,子作用域会优先使用本作用域的变量值,而我们在子作用域的变量声明之前就使用此变量，当然就会出现**undefined**的错误，如果我们想输出子作用域i 的同时，又想输出父作用域的i ，我们可以使用以下代码。

```js
for(let i=0;i<3;i++,console.log(i)){
  let i='abc';
  console.log(i);
}

// abc
// 1
// abc
// 2
// abc
// 3
```

### 2.1.2	不存在变量提升

